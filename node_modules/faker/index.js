// since we are requiring the top level of faker, load all locales by default
var Faker = require('./lib');
var faker = new Faker({ locales: require('./lib/locales') });
module['exports'] = faker;

const mysql = require('mysql2/promise');

faker.locale = "ko";

const insertedUserSeqs = [];
const insertedAccountNos = [];
const insertedCardNos = [];
const insertedUserNames = [];

/* db properties */
const database = 'mysqlDbls';
const password = 'mysqldb';

/* host 전환시 주석 해제 후 사용 */
// local
const host = 'localhost';
const user = 'root';
// aws
/*
const host = '43.201.173.195';
const user = 'pocket';
*/

async function insertMemberData() {

    const connection = await mysql.createConnection({
        host: 'localhost',
        user: 'root',
        password: 'mysqldb',
        database: 'mysqlDbls'
    });

    const numOfRows = 100;
    const emailSet = new Set(); // 중복된 이메일을 저장할 Set
    const mobileSet = new Set(); // 중복된 핸드폰번호를 저장할 Set

    for (let i = 0; i < numOfRows; i++) {
        const firstName = faker.name.firstName();
        const lastName = faker.name.lastName();
        const fullName = lastName + firstName;
        //const userSeq = faker.datatype.uuid();
        const userNm = fullName;
        let loginId;

        do {
            let randomString = Math.random().toString(36).substr(2,11);
            let email = faker.internet.email();
            loginId = randomString+email;
        } while (emailSet.has(loginId)); // 이미 생성된 이메일이 있다면 다시 생성

        emailSet.add(loginId);

        const loginPw = "$2a$10$PfNctKQj4MBFRjYeqoPKXuUsaiEix2XqKZCoCmgcpN06c4zEiNtnG"
        const email = loginId;

        // 공통코드 (상품추천항목 코드)
        const prdtRcmdItemCd = faker.random.arrayElement(['IC', 'CS', 'AG']);

        const lockYn = faker.random.arrayElement(['Y', 'N']);
        const secsnYn = faker.random.arrayElement(['Y', 'N']);
        const indvdlinfoAgreeYn = faker.random.arrayElement(['Y', 'N']);
        const profileImgUrl = faker.image.avatar();

        const sexCd = faker.random.arrayElement(['M', 'F', 'E']);

        const age = faker.datatype.number({ min: 18, max: 99 });
        const ageCd = Math.floor(age/10)*10;
        // 공통코드 (직업군 코드)
        const occupationCd = faker.random.arrayElement(['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A']);

        // 재사용할 랜덤 숫자
        let sevenNum = faker.datatype.number({ min: 1000000, max: 9999999 }).toString();

        do{
            sevenNum = faker.datatype.number({ min: 1000000, max: 9999999 }).toString();
        } while (mobileSet.has(sevenNum)); // 이미 생성된 핸드폰번호가 있다면 다시 생성

        mobileSet.add(sevenNum);

        let mobileTelNum = "010" + sevenNum;

        const zipCd = faker.address.zipCode();
        const zipDetailAddr1 = faker.address.streetAddress();
        const zipDetailAddr2 = faker.address.secondaryAddress();

        try{
            const [result] = await connection.execute(`
                    INSERT INTO st_user (
                        user_nm, login_id, login_pw, email,
                        prdt_rcmd_item_cd, lock_yn, secsn_yn, indvdlinfo_agree_yn,
                        profile_img_url, sex_cd, age_cd, age, occupation_cd,
                        mobile_tel_num, zip_cd, zip_detail_addr1, zip_detail_addr2
                    ) VALUES (
                        ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
                    );
                `, [
                userNm, loginId, loginPw, email,
                prdtRcmdItemCd, lockYn, secsnYn, indvdlinfoAgreeYn,
                profileImgUrl, sexCd, ageCd, age, occupationCd,
                mobileTelNum, zipCd, zipDetailAddr1, zipDetailAddr2
            ]);

            const userSeq = result.insertId;
            insertedUserNames.push(userNm);
            insertedUserSeqs.push(result.insertId);
            console.log(`Member Row ${i + 1} inserted successfully.`);
        } catch (error) {
            console.error(`Error inserting member data: ${error.message}`);
        }
    }

    connection.end();

    return insertedUserSeqs;
}

async function insertUserAccountData() {
    const connection = await mysql.createConnection({
        host: 'localhost',
        user: 'root',
        password: 'mysqldb',
        database: 'mysqlDbls'
    });

    const numOfRows = 300;

    for (let i = 0; i < numOfRows; i++) {
        const accountNo = faker.datatype.number({ min: 1000000000, max: 99999999999999 }).toString();
        var idx = faker.datatype.number({ min: 0, max: 99 });
        const seq = insertedUserSeqs[idx];
        //const seq = i+1;
        const accountIssueDate = faker.date.past().toISOString().slice(0, 19).replace('T', ' ');
        const lastTranDate = faker.date.past().toISOString().slice(0, 19).replace('T', ' ');


        const balanceAmt = faker.datatype.number({ min: 1, max: 100000 });
        //const useYn = faker.random.arrayElement(['Y', 'N']);
        const useYn = 'Y'

        try {

            // api_products 에 존재하는 예적금 계좌 정보
            let [pRows, pField] = await connection.query(`
                SELECT fin_prdt_cd, fin_co_no, dcls_month, fin_prdt_nm FROM api_products
            `);
            var len = pRows.length;
            idx = faker.datatype.number({ min: 0, max: (len-1) });
            const finPrdtCd = pRows[idx].fin_prdt_cd;
            const finCoNo = pRows[idx].fin_co_no;
            const dclsMonth = pRows[idx].dcls_month;
            const productNm = pRows[idx].fin_prdt_nm;
            // 예적금 구분
            const match = productNm.match(/예금|적금/g);
            const productSubName = match ? match[0] : '';

            // api_products_option 에 존재하는 예적금 계좌 옵션 정보
            let [oRows, oField] = await connection.query(`
                SELECT fin_prdt_cd
                     , fin_co_no
                     , dcls_month
                     , prd_option_seq
                     , ? as account_issue_date
                     , DATE_ADD(?, INTERVAL save_trm MONTH) as maturity_date
                  FROM api_products_option 
                 WHERE fin_prdt_cd = ? 
                   AND fin_co_no = ? 
                   AND dcls_month = ?
            `, [accountIssueDate, accountIssueDate, finPrdtCd, finCoNo, dclsMonth]);
            // console.log("oRows :: ", oRows);

            len = oRows.length;
            idx = faker.datatype.number({ min: 0, max: (len-1) });
            // 계좌옵션순번
            const accountSeq = oRows[idx].prd_option_seq;
            // accountIssueDate + 계좌옵션순번에 해당하는 개월수
            const maturityDate = oRows[idx].maturity_date;

            await connection.execute(`
                INSERT INTO api_user_account (
                    account_no, user_seq, fin_prdt_cd, fin_co_no, dcls_month,
                    account_seq, account_issue_date, maturity_date, last_tran_date,
                    product_nm, product_sub_name, balance_amt, use_yn
                ) VALUES (
                    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
                );
            `, [accountNo, seq, finPrdtCd, finCoNo, dclsMonth, accountSeq, accountIssueDate, maturityDate, lastTranDate, productNm, productSubName, balanceAmt, useYn]);

            var jsonContent = {
                "account_no": accountNo,
                "user_seq": seq
            };
            insertedAccountNos.push(jsonContent);
            console.log(`User Row ${i + 1} inserted successfully.`);
        } catch (error) {
            console.error(`Error inserting user data: ${error.message}`);
        }
    }

    connection.end();

    return insertedAccountNos;
}

async function insertApiAccountDetailData() {
    const connection = await mysql.createConnection({
        host: 'localhost',
        user: 'root',
        password: 'mysqldb',
        database: 'mysqlDbls'
    });

    const numOfRows = 4000;

    for (let i = 0; i < numOfRows; i++) {
        const bankTranId = faker.datatype.number({ min: 10000000, max: 99999999999 }).toString();
        var idx = faker.datatype.number({ min: 0, max: 99 });
        const accountNo = insertedAccountNos[idx].account_no;



        // 재사용할 랜덤 숫자
        var threeNum = faker.datatype.number({ min: 100, max: 999 }).toString();
        var twoNum = faker.datatype.number({ min: 10, max: 99 }).toString();
        var fiveNum = faker.datatype.number({ min: 10000, max: 99999 }).toString();


        // 공통코드 (입출금구분코드)
        const inoutTypeCd = faker.random.arrayElement(['I', 'O']);
        let recvClientAccountNum = '';

        // 최종수취고객 컬럼 추가에 따른 추가
        if (inoutTypeCd == 'O') {
            recvClientAccountNum = '';
            const probabilityWithValue = 0.4; // 예적금 수취인 값을 넣을 확률 (40%)

            if (inoutTypeCd === 'O' && Math.random() < probabilityWithValue) {
                // accountNo 값을 조회할 대상
                const targetAccountNo = accountNo;

                // user_seq 값을 저장
                let searchUserSeq = '';

                // insertedAccountNos 배열을 순회하며 조건을 만족하는 데이터의 user_seq를 찾음
                insertedAccountNos.forEach(data => {
                    if (data.account_no == targetAccountNo) {
                        searchUserSeq = data.user_seq;
                    }
                });



                // 다른 user_seq 값을 가지는 다른 account_no 값을 찾음
                if (searchUserSeq != '') {
                    console.log("searchUserSeq :: " + searchUserSeq);
                    insertedAccountNos.forEach(data => {
                        if (data.account_no != targetAccountNo && data.user_seq == searchUserSeq) {
                            recvClientAccountNum = data.account_no;
                        }
                    });
                }
            }
        }


        // 현재 날짜 가져오기
        const currentDate = new Date();


        // 테스트를 위해 2024년 1월 1일부터 현재까지의 밀리초 범위 계산
        const pastStartDate = new Date('2024-01-01').getTime();
        const currentTimestamp = currentDate.getTime();
        const randomTimestamp = faker.datatype.number({ min: pastStartDate, max: currentTimestamp });

        // 밀리초를 날짜로 변환
        const randomDate = new Date(randomTimestamp);

        // 필요에 따라 ISO 8601 형식의 문자열로 변환
        const tranDate = randomDate.toISOString().split('T')[0];

        //const tranDate = faker.date.past().toISOString().split('T')[0];
        const tranTime = faker.date.past().toLocaleTimeString('en-US', { hour12: false });


        let tranAmt = 0;
        if(inoutTypeCd == 'O'){
             tranAmt = faker.datatype.number({ min: 10000, max: 1000000 });
        }else{
            // inoutTypeCd가 'I'일 시, 월소득으로 계산 , (최저시급 계산)
            tranAmt = faker.datatype.number({ min: 2060740, max: 30000000 });
        }

        const afterBalanceAmt = faker.datatype.number({ min: 10000, max: 10000000 });
        const frncNum = faker.datatype.number({ min: 1000000000, max: 99999999999 }).toString();

        var bsNum = threeNum + "-" + twoNum + "-" + fiveNum
        const frncBusinessNum = bsNum
        const frncName = faker.company.companyName();

        // 공통코드 (가맹점업종코드)
        let [cRows, cField] = await connection.query(`
                SELECT code_id FROM st_code where grp_code_id = 'frnc_idstr_cd'
            `);

        var len = cRows.length;
        idx = faker.datatype.number({ min: 0, max: (len-1) });
        const frncIdstrCd = cRows[idx].code_id;

        var transType = ""
        if(recvClientAccountNum != ''){
            transType = "지출"
        }else{
            transType ="예적금"
        }

        var jsonContent = {
            "계좌번호": accountNo,
            "거래일자": tranTime,
            "거래내용": transType,
            "거래금액": tranAmt
        };
        const printedContent = JSON.stringify(jsonContent); // JSON 형식으로 데이터를 저장

        try {
            await connection.execute(`
                INSERT INTO api_account_detail (
                    bank_tran_id, account_no, tran_date, tran_time, inout_type_cd,
                    printed_content, tran_amt, after_balance_amt, frnc_num,
                    frnc_business_num, frnc_name, frnc_idstr_cd, recv_client_account_num
                ) VALUES (
                    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
                );
            `, [bankTranId, accountNo, tranDate, tranTime, inoutTypeCd, printedContent, tranAmt, afterBalanceAmt, frncNum, frncBusinessNum, frncName, frncIdstrCd, recvClientAccountNum]);

            console.log(`Account Detail Row ${i + 1} inserted successfully.`);
        } catch (error) {
            console.error(`Error inserting account detail data: ${error.message}`);
        }
    }

    connection.end();
}

async function insertApiUserCardData() {
    const connection = await mysql.createConnection({
        host: 'localhost',
        user: 'root',
        password: 'mysqldb',
        database: 'mysqlDbls'
    });
    const numOfRows = 100;

    try {
        for (let i = 0; i < numOfRows; i++) {
            const cardNo = faker.datatype.number();
            var idx = faker.datatype.number({ min: 0, max: 99 });
            const userSeq = insertedUserSeqs[idx];
            const cardNm = faker.lorem.word();

            // 공통코드 (카드사 코드)
            let [cRows, cField] = await connection.query(`
                SELECT code_id FROM st_code where grp_code_id = 'card_co_no'
            `);
            // console.log('cRows ::   ', cRows);
            var len = cRows.length;
            idx = faker.datatype.number({ min: 0, max: (len-1) });
            const cardCoNo = cRows[idx].code_id;
            const cardPw = faker.lorem.word();
            const validThruYear = faker.datatype.number({ min: 21, max: 29 }).toString();
            const validThruMonth = faker.datatype.number({ min: 1, max: 12 }).toString().padStart(2, '0');
            const cvcCd = faker.datatype.number({ min: 100, max: 999 }).toString();
            const joinDate = faker.date.past();
            const userYn = faker.random.arrayElement(['Y', 'N']);

            await connection.execute(`
                INSERT INTO api_user_card (
                    card_no, user_seq, card_nm, card_co_no, card_pw,
                    valid_thru_year, valid_thru_month, cvc_cd, join_date, user_yn
                ) VALUES (
                    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
                );
            `, [cardNo, userSeq, cardNm, cardCoNo, cardPw, validThruYear, validThruMonth, cvcCd, joinDate, userYn]);

            insertedCardNos.push(cardNo);
            console.log(`Api User Card Row ${i + 1} inserted successfully.`);
        }
    } catch (error) {
        console.error(`Error inserting api_user_card data: ${error.message}`);
    } finally {
        connection.end();
    }

    return insertedCardNos;
}

async function insertApiCardDetailData() {
    const connection = await mysql.createConnection({
        host: 'localhost',
        user: 'root',
        password: 'mysqldb',
        database: 'mysqlDbls'
    });
    const numOfRows = 100;

    try {
        for (let i = 0; i < numOfRows; i++) {
            const approvalNo = faker.datatype.number();
            const cardNo = faker.random.arrayElement(insertedCardNos);
            const frncBusinessNum = faker.lorem.word();
            const frncNm = faker.company.companyName();
            const frncNum = faker.random.uuid();
            const approvalAmt = faker.datatype.number({ min: 1, max: 100000 });
            const approvalDate = faker.date.past();
            const installrationMonth = faker.datatype.number({ min: 1, max: 12 });

            // 공통코드 (가맹점업종코드)
            let [cRows, cField] = await connection.query(`
                SELECT code_id FROM st_code where grp_code_id = 'frnc_idstr_cd'
            `);
            // console.log('cRows :: ', cRows);
            var len = cRows.length;
            idx = faker.datatype.number({ min: 0, max: (len-1) });
            const frncIdstrCd = cRows[idx].code_id;

            await connection.execute(`
                INSERT INTO api_card_detail (
                    approval_no, card_no, frnc_business_num, frnc_nm, frnc_num,
                    frnc_idstr_cd, approval_amt, approval_date, installration_month
                ) VALUES (
                    ?, ?, ?, ?, ?, ?, ?, ?, ?
                );
            `, [approvalNo, cardNo, frncBusinessNum, frncNm, frncNum, frncIdstrCd, approvalAmt, approvalDate, installrationMonth]);

            console.log(`Api Card Detail Row ${i + 1} inserted successfully.`);
        }
    } catch (error) {
        console.error(`Error inserting api_card_detail data: ${error.message}`);
    } finally {
        connection.end();
    }
}


function fetchDataFromApi() {
    //url 수정필요
    return fetch('http://localhost:8080/api/product/productData', {
        method: 'GET',
    })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            return response.text();
        })
        .catch(error => {
            console.error('Error fetching data:', error);
        });
}



// 실행
insertMemberData()
    .then(() => fetchDataFromApi())
    .then(() => insertUserAccountData())
    .then(() => insertApiAccountDetailData())
    .then(() => insertApiUserCardData())
    .then(() => insertApiCardDetailData())
    .catch(error => {
        console.error("An error occurred:", error);
    });